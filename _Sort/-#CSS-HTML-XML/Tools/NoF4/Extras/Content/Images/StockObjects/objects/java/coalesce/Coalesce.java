import java.awt.*;import java.applet.*;import java.util.*;import java.net.*;import java.awt.image.*;public class Coalesce extends Applet implements Runnable {    protected char              separated[];    protected char              separateda[][];    protected Thread            StringThread = null;    protected int               xlocation[];    protected int               xlocationa[][];    protected int               xwidth[];    protected int               xwidtha[][];    protected boolean           threadSuspended = false;    protected int               chardelay;    protected int               rundelay;    protected boolean           endofstring = false;    protected int               total_width;    protected int               total_widtha[];    protected boolean           thread_running;    // Parameters that apply to the entire applet    protected Color       app_bg_color;         // Applet background color    protected Image       offScreen;    protected Graphics    offGC;    protected int         applet_width;    protected int         applet_height;    protected int         app_height;    protected int         app_width;    protected String      bgimage_file;    protected Image       bgimage;    protected boolean     tile;    protected int         bgimage_height;    protected int         bgimage_width;    protected Image       tiled_bgimage;    protected Graphics    bg_g;    // Parameters specific to Text    protected String      tx;                // Text    protected String      txa[];             // Text array    protected int         xoffset;           // Text X offset    protected int         yoffset;           // Text Y offset    protected Color       textcolor;         // Text color    protected boolean     horizcenter;       // Text horizontally centered    protected boolean     vertcenter;        // Text vertically centered    protected Font        font;              // Text font    protected FontMetrics fontmetrics;       // Text font metrics    protected boolean     underline;         // Text underline    protected int         width;             // Text width    protected int         widtha[];          // Text width array    protected int         height;            // Text height    protected int         ascent;            // Text ascent    protected int         descent;           // Text descent    protected int         txcount;           // number of texts    protected int         Index = 0;              // Index    protected int         xval[];                 // X values for char position    protected int         yval[];                 // Y values for char position    protected boolean     coalescing = true;      // Direction    protected int         steps;                  // Number of steps in movement    public void init() {//This procedure will watermark the applet in case of theft.//----------------------------------------------        boolean pirated;        String host;        String msg;        host=getDocumentBase().getHost();        pirated=!host.equals("www.stockobjects.com");        if(pirated) {                msg="    Property of Rhizome StockObjects...Unauthorized use prohibited.";                add(new Label(msg));                }//----------------------------------------------        int i, j;        // Applet parameters        app_bg_color    = GetParmToColor("AppBGColor", null);        // Text parameters        txcount      = GetParmToInt("TextCount", 0);        tx           = GetParmToString("Text", "");        xoffset      = GetParmToInt("XOffset", 0);        yoffset      = GetParmToInt("YOffset", -1);        textcolor    = GetParmToColor("TextColor", null);        horizcenter  = GetParmToBoolean("HorizCenter", false);        vertcenter   = GetParmToBoolean("VertCenter",  false);        font         = GetParmToFont("Font",                                               "Style",                                               "PointSize");        if(txcount > 0)            txa = new String[txcount];        for(i=0;i < txcount;i++)            txa[i] = GetParmToString("Text"+(i+1), "");        chardelay      = GetParmToInt("DelayBetweenChars", 20);        rundelay       = GetParmToInt("DelayBetweenRuns", 3000);        // ======== BG Image ===========        tile           = GetParmToBoolean("AppTile",     false);        bgimage_file   = GetParmToString("AppBGImage",  null);        if(bgimage_file != null) {            bgimage = process(getDocumentBase(), bgimage_file, false);            prepareImage(bgimage);            bgimage_width = getWidth(bgimage, this);            bgimage_height = getHeight(bgimage, this);        }        setFont(font);        fontmetrics = getFontMetrics(font);        width  = fontmetrics.stringWidth(tx);        height = fontmetrics.getHeight();        ascent = fontmetrics.getMaxAscent();        descent = fontmetrics.getDescent();        if(txcount > 0)            widtha = new int[txcount];        for(i=0;i < txcount;i++)            widtha[i]  = fontmetrics.stringWidth(txa[i]);        // Set the background and foreground colors, if specified        if(app_bg_color != null)            setBackground(app_bg_color);        else            app_bg_color = getBackground();        if(textcolor != null)            setForeground(textcolor);        else            textcolor = getForeground();        // Allocate space for array of chars, location, and width        separated =  new char [tx.length()];        xlocation =  new int  [tx.length()];        xwidth    =  new int  [tx.length()];        if(txcount > 0) {            separateda = new char[txcount][];            xlocationa = new int [txcount][];            xwidtha    = new int [txcount][];        }        for(i=0;i < txcount;i++) {            separateda[i] =  new char [txa[i].length()];            xlocationa[i] =  new int  [txa[i].length()];            xwidtha[i]    =  new int  [txa[i].length()];            txa[i].getChars(0, txa[i].length(), separateda[i], 0);        }        // Put each character from the string into the separated array        tx.getChars(0,tx.length(),separated,0);        // Calculate the x locations for each character based on width        if(txcount > 0)            total_widtha = new int[txcount];        for(i=0;i < txcount;i++)            total_widtha[i] = 0;        for(i=0;i<txcount;i++) {            for(j=0;j<txa[i].length();j++) {                xwidtha[i][j] = fontmetrics.charWidth(separateda[i][j]);                total_widtha[i] += xwidtha[i][j];                if(j+1<txa[i].length())                    xlocationa[i][j+1] = total_widtha[i];            }        }        total_width = 0;        for(i=0;i<tx.length();i++) {            xwidth[i] = fontmetrics.charWidth(separated[i]);            total_width += xwidth[i];            if(i+1<tx.length())                xlocation[i+1] = total_width;        }        offScreen = createImage(size().width, size().height);        offGC = offScreen.getGraphics();        offGC.setFont(font);        steps = GetParmToInt("Steps", 50);        // tx is set up in StringAnimation        xval =  new int [tx.length()];        yval =  new int [tx.length()];        // Calculate original random positions        calc_new_random();    }    public void paint(Graphics g) {        // If this is the first time we've been in paint        // or the applet has changed size then create        // an image the size of the applet into which        // we write the background image        if(applet_width != size().width ||           applet_height!= size().height) {            applet_width  = size().width;            applet_height = size().height;            offScreen = createImage(applet_width, applet_height);            offGC = offScreen.getGraphics();            offGC.setFont(font);        }        // We never know when the size might change so check it every time        if(horizcenter) {            xoffset = (size().width / 2) - (total_width / 2);        }        if(vertcenter) {            yoffset = (size().height / 2) + (ascent / 3);        } else if(yoffset == -1) {            yoffset = height - descent;        }	offGC.setColor(getBackground());	offGC.fillRect(0, 0, applet_width, applet_height);	tilebackground(offGC);        if(Index == 0) {            offGC.setColor(getBackground());            offGC.fillRect(0, 0, size().width, size().height);        }        offGC.setColor(getBackground());        offGC.fillRect(0, 0, size().width, size().height);        tilebackground(offGC);        offGC.setColor(getForeground());        for(int i=0;i<tx.length();i++) {            offGC.drawChars(separated, i, 1,                calcval(xval[i], xoffset+xlocation[i], Index, steps),                calcval(yval[i], yoffset, Index, steps));        }        g.drawImage(offScreen, 0, 0, this);    }    public void run() {        while (StringThread != null) {            if(coalescing) {                Index++;                if(Index > steps) {                    Index = steps;                    calc_new_random();                    coalescing = false;		    StringThread = null;                }            } else {                Index--;                if(Index < 0) {                    Index = 0;                    coalescing = true;		    StringThread = null;                }            }	    repaint();            try {Thread.sleep(chardelay);} catch (InterruptedException e){}        }    }    public int calcval(int from, int to, int index, int range) {        int value;        if(from == to) {            value = from;        } else if(from > to) {            value = from - ((from - to) * index / range);        } else {            value = from + ((to - from) * index / range);        }        return value;    }    public synchronized boolean mouseEnter(Event evt, int x, int y) {        if(StringThread == null) {            StringThread = new Thread(this);            StringThread.start();        } else {            coalescing = true;        }        return true;    }    public synchronized boolean mouseExit(Event evt, int x, int y) {        if(StringThread == null) {            StringThread = new Thread(this);            StringThread.start();        } else {            coalescing = false;        }        return true;    }    public boolean keyDown(Event evt, int key) {        int x = evt.x;        int y = evt.y;        if(key == 'f') {            chardelay *= .9;            if(chardelay < 10)                chardelay = 10;            getAppletContext().showStatus("Setting image delay to: " +                        chardelay);        } else if(key == 's') {            if(chardelay < 10)                chardelay++;            else                chardelay *= 1.1;            getAppletContext().showStatus("Setting image delay to: " +                        chardelay);        }        return true;    }    public void start() {        Index = 0;    }    public void calc_new_random() {        for(int i=0;i<tx.length();i++) {            xval[i] = (int)((Math.random()*1000.0) % size().width);            yval[i] = (int)((Math.random()*1000.0) % size().height);        }    }// Begin - Included from SAnimate.include    //    // Overwrite the default update method    // This may not be necessary for this case    // but it certainly doesn't hurt    //    public void update(Graphics g) {        paint(g);    }    public void stop() {        if(StringThread != null)            StringThread.stop();        StringThread = null;    }    //    // Tile the background with the specified image    //    protected void tilebackground(Graphics g) {        int i, j;        if(bgimage == null)            return;        if(isImagePrepared(bgimage) == false)            loadImageAndWait(bgimage);        //        // If the applet has changed size or this is the first time        // tilebackground has been called then create the bg image        //        if(app_width != size().width || app_height != size().height) {            app_width  = size().width;            app_height = size().height;            tiled_bgimage = createImage(size().width, size().height);            bg_g = tiled_bgimage.getGraphics();            bg_g.setColor(app_bg_color);            bg_g.fillRect(0, 0, size().width, size().height);            if(tile) {                for(i=-bgimage_height;i<app_height;i+=bgimage_height) {                    for(j=-bgimage_width;j<app_width;j+=bgimage_width) {                        bg_g.drawImage(bgimage, j+2, i+2, this);                    }                }            } else {                bg_g.drawImage(bgimage, 0, 0, this);            }        }        if(tiled_bgimage != null) {            g.drawImage(tiled_bgimage, 0, 0, this);        }    }// End - Included from SAnimate.include// Begin - Included from GetParm.include    public int GetParmToInt(String par, int defaultval) {        String s = getParameter(par);        if(s == null)            return defaultval;        else            return(Integer.parseInt(s));    }    public String GetParmToString(String par, String defaultval) {        String s = getParameter(par);        if(s == null)            return defaultval;        else            return(s);    }    public boolean GetParmToBoolean(                            String par,                            boolean defaultval) {        String s = getParameter(par);        if(s == null)            return defaultval;        else            return(s.equalsIgnoreCase("true"));    }    public Color GetParmToColor(                            String par,                            Color defaultval) {        Color color;        String s = getParameter(par);        if(s == null)            return defaultval;        else {            try {                if(s.charAt(0) == '#') {                    char chars[];                    // Get rid of leading #                    chars =  new char [s.length()];                    s.getChars(0, s.length(), chars, 0);                    color = new Color(Integer.parseInt(                            new String(chars, 1, s.length()-1),16));                    return(new Color(Integer.parseInt(                            new String(chars, 1, s.length()-1), 16)));                } else {                    color = new Color(Integer.parseInt(s, 16));                    return(color);                }            } catch (NumberFormatException e) {                String retcolor;                retcolor = getColor(s);                if(retcolor != null)                    return(new Color(Integer.parseInt(retcolor, 16)));                else                    System.out.println("Bad color specification: " + e.getMessage());                return null;            }        }    }    public URL GetParmToURL(                            String par) {        URL url = null;        String s = getParameter(par);        if(s == null)            return null;        else {            try {                url = new URL(s);            } catch(MalformedURLException e) {                url = null;            }            if(url == null) {                // The URL may be specified as relative to                // the HTML document base in which the URL resides                // We should be able to handle that                try {                    url = new URL(getDocumentBase(), s);                } catch(MalformedURLException e) {                    url = null;                }            }            if(url == null) {                // The URL may be specified as relative to                // the Code base (though that seems rather                // unlikely)                //                try {                    url = new URL(getCodeBase(), s);                } catch(MalformedURLException e) {                    url = null;                }            }            if(url == null)                System.out.println("Unable to load URL: " + s);        }        return url;    }    public Font GetParmToFont(                            String par1,                            String par2,                            String par3) {        String fontname;        String fontstyle;        int style = -1;        int psize;        Font font;        Font currentfont;        String psize_str;        currentfont = getFont();        fontname = getParameter(par1);        if(fontname == null)            fontname = currentfont.getName();        fontstyle = getParameter(par2);        if(fontstyle == null)            style = currentfont.getStyle();        // Get the Font        if(fontname.equalsIgnoreCase("TimesRoman")  ||           fontname.equalsIgnoreCase("Helvetica")   ||           fontname.equalsIgnoreCase("Courier")     ||           fontname.equalsIgnoreCase("Dialog")      ||           fontname.equalsIgnoreCase("DialogInput") ||           fontname.equalsIgnoreCase("ZapfDingbats")) {                // Do Nothing, we got a valid font        } else {            fontname = currentfont.getName();        }        if(style == -1) {            // Get the Font Style            if(fontstyle.equalsIgnoreCase("bold"))                style = Font.BOLD;            else if(fontstyle.equalsIgnoreCase("italic"))                style = Font.ITALIC;            else if(fontstyle.equalsIgnoreCase("bolditalic"))                style = Font.ITALIC|Font.BOLD;            else                style = Font.PLAIN;        }        psize_str = getParameter(par3);        if(psize_str == null)            psize = currentfont.getSize();        else {            try {                psize = Integer.parseInt(psize_str);            } catch (NumberFormatException e) {                psize = currentfont.getSize();                System.out.println("NumberformatException: " + psize_str);            }        }        // Set up the font stuff        font = new Font(fontname, style, psize);        return font;    }    Hashtable colors;    public String getColor(String name) {        if(colors == null)            createHashTable();        return (String)colors.get(name);    }    public void createHashTable() {        if(colors != null)            return;        colors = new Hashtable(650);        colors.put("aliceblue",         "f0f8ff");        colors.put("antiquewhite",      "faebd7");        colors.put("aquamarine",        "7fffd4");        colors.put("azure",             "f0ffff");        colors.put("beige",             "f5f5dc");        colors.put("bisque",            "ffe4c4");        colors.put("black",             "000000");        colors.put("blanchedalmond",    "ffebcd");        colors.put("blue",              "0000ff");        colors.put("blueviolet",        "8a2be2");        colors.put("brown",             "a52a2a");        colors.put("burlywood",         "deb887");        colors.put("cadetblue",         "5f9ea0");        colors.put("chartreuse",        "7fff00");        colors.put("chocolate",         "d2691e");        colors.put("coral",             "ff7f50");        colors.put("cornflowerblue",    "6495ed");        colors.put("cornsilk",          "fff8dc");        colors.put("cyan",              "00ffff");        colors.put("darkgoldenrod",     "b8860b");        colors.put("darkgreen",         "006400");        colors.put("darkkhaki",         "bdb76b");        colors.put("darkolivegreen",    "556b2f");        colors.put("darkorange",        "ff8c00");        colors.put("darkorchid",        "9932cc");        colors.put("darksalmon",        "e9967a");        colors.put("darkseagreen",      "8fbc8f");        colors.put("darkslateblue",     "483d8b");        colors.put("darkslategray",     "2f4f4f");        colors.put("darkslategrey",     "2f4f4f");        colors.put("darkturquoise",     "00ced1");        colors.put("darkviolet",        "9400d3");        colors.put("deeppink",          "ff1493");        colors.put("deepskyblue",       "00bfff");        colors.put("dimgray",           "696969");        colors.put("dimgrey",           "696969");        colors.put("dodgerblue",        "1e90ff");        colors.put("firebrick",         "b22222");        colors.put("floralwhite",       "fffaf0");        colors.put("forestgreen",       "228b22");        colors.put("green",             "00ff00");        colors.put("gainsboro",         "dcdcdc");        colors.put("ghostwhite",        "f8f8ff");        colors.put("gold",              "ffd700");        colors.put("goldenrod",         "daa520");        colors.put("gray",              "bebebe");        colors.put("honeydew",          "f0fff0");        colors.put("hotpink",           "ff69b4");        colors.put("indianred",         "cd5c5c");        colors.put("ivory",             "fffff0");        colors.put("khaki",             "f0e68c");        colors.put("lavender",          "e6e6fa");        colors.put("lavenderblush",     "fff0f5");        colors.put("lawngreen",         "7cfc00");        colors.put("lemonchiffon",      "fffacd");        colors.put("lightblue",         "add8e6");        colors.put("lightcoral",        "f08080");        colors.put("lightcyan",         "e0ffff");        colors.put("lightgoldenrod",    "eedd82");        colors.put("lightgoldenrodyellow","fafad2");        colors.put("lightgray",         "d3d3d3");        colors.put("lightgrey",         "d3d3d3");        colors.put("lightpink",         "ffb6c1");        colors.put("lightsalmon",       "ffa07a");        colors.put("lightseagreen",     "20b2aa");        colors.put("lightskyblue",      "87cefa");        colors.put("lightslateblue",    "8470ff");        colors.put("lightslategray",    "778899");        colors.put("lightslategrey",    "778899");        colors.put("lightsteelblue",    "b0c4de");        colors.put("lightyellow",       "ffffe0");        colors.put("limegreen",         "32cd32");        colors.put("linen",             "faf0e6");        colors.put("magenta",           "ff00ff");        colors.put("maroon",            "b03060");        colors.put("mediumaquamarine",  "66cdaa");        colors.put("mediumblue",        "0000cd");        colors.put("mediumorchid",      "ba55d3");        colors.put("mediumpurple",      "9370db");        colors.put("mediumseagreen",    "3cb371");        colors.put("mediumslateblue",   "7b68ee");        colors.put("mediumspringgreen", "00fa9a");        colors.put("mediumturquoise",   "48d1cc");        colors.put("mediumvioletred",   "c71585");        colors.put("midnightblue",      "191970");        colors.put("mintcream",         "f5fffa");        colors.put("mistyrose",         "ffe4e1");        colors.put("moccasin",          "ffe4b5");        colors.put("navajowhite",       "ffdead");        colors.put("navy",              "000080");        colors.put("navyblue",          "000080");        colors.put("oldlace",           "fdf5e6");        colors.put("olivedrab",         "6b8e23");        colors.put("orange",            "ffa500");        colors.put("orangered",         "ff4500");        colors.put("orchid",            "da70d6");        colors.put("palegoldenrod",     "eee8aa");        colors.put("palegreen",         "98fb98");        colors.put("paleturquoise",     "afeeee");        colors.put("palevioletred",     "db7093");        colors.put("papayawhip",        "ffefd5");        colors.put("peachpuff",         "ffdab9");        colors.put("peru",              "cd853f");        colors.put("pink",              "ffc0cb");        colors.put("plum",              "dda0dd");        colors.put("powderblue",        "b0e0e6");        colors.put("purple",            "a020f0");        colors.put("red",               "ff0000");        colors.put("rosybrown",         "bc8f8f");        colors.put("royalblue",         "4169e1");        colors.put("saddlebrown",       "8b4513");        colors.put("salmon",            "fa8072");        colors.put("sandybrown",        "f4a460");        colors.put("seagreen",          "2e8b57");        colors.put("seashell",          "fff5ee");        colors.put("sienna",            "a0522d");        colors.put("skyblue",           "87ceeb");        colors.put("slateblue",         "6a5acd");        colors.put("slategray",         "708090");        colors.put("slategrey",         "708090");        colors.put("snow",              "fffafa");        colors.put("springgreen",       "00ff7f");        colors.put("steelblue",         "4682b4");        colors.put("tan",               "d2b48c");        colors.put("thistle",           "d8bfd8");        colors.put("tomato",            "ff6347");        colors.put("turquoise",         "40e0d0");        colors.put("violet",            "ee82ee");        colors.put("violetred",         "d02090");        colors.put("wheat",             "f5deb3");        colors.put("white",             "ffffff");        colors.put("whitesmoke",        "f5f5f5");        colors.put("yellow",            "ffff00");        colors.put("yellowgreen",       "9acd32");    }// End - Included from ColrLook.include// End - Included from GetParm.include// Begin - Included from ImgGetr.include    public Image process(URL url, String file, boolean loadnow) {	Image image;        // See if the user specified an Image parameter        // If not, return        if(file == null)            return null;	image = getImage(url, file);	if(loadnow)	    loadImageAndWait(image);        return image;    }    /**     * Checks to see if the specified image is actually     * prepared (loaded) and ready to display     * Return true if loaded, otherwise false     *     * @param image the image to check     */    public boolean isImagePrepared(Image image) {        boolean ImagePrepared;        ImagePrepared = prepareImage(image, this);        return ImagePrepared;    }    /**     * Begins the preparation (loading) of the image     * This function returns immediately     * The image is loaded in a thread     *     * @param image the image to prepare     */    public void prepareImage(Image image) {        boolean ImagePrepared;        ImagePrepared = prepareImage(image, this);    }    /**     * Prepares (loads) the image and does not return     * until the loading is complete     *     * @param image the image to load     */    public synchronized void loadImageAndWait(Image image) {        int checkImageFlags;        boolean ImagePrepared;        ImagePrepared = prepareImage(image, this);        if(ImagePrepared == false) {            while(((checkImageFlags =                    checkImage(image, this)) &                            ImageObserver.ALLBITS) == 0) {                try {                    wait(100);                } catch (InterruptedException e){}            }        }    }    public synchronized int getWidth(Image image, ImageObserver observer) {        int width;        while((width = image.getWidth(observer)) == -1) {            try {wait(100);} catch (InterruptedException e){}        }        return width;    }    public synchronized int getHeight(Image image, ImageObserver observer) {        int height;        while((height = image.getHeight(observer)) == -1) {            try {wait(100);} catch (InterruptedException e){}        }        return height;    }// End - Included from ImgGetr.include} 